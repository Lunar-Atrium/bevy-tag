//! Traits for namespace tags and GID conversion.
//!
//! These traits are implemented by types generated from the `namespace!` macro,
//! enabling zero-cost conversion from typed tags to GID.

use core::marker::PhantomData;

use crate::registry::NamespaceRegistry;
use crate::GID;

/// A zero-cost wrapper indicating this tag path was redirected to another tag.
///
/// Similar to UE5's Core Redirects, when a tag is renamed or moved, the old
/// path is preserved as a `Redirect<T>` pointing to the canonical tag `T`.
/// This makes the redirection explicit in the type system.
///
/// **Key behavior:**
/// - `Redirect<T>::GID` returns `T::GID` (same GID as canonical tag)
/// - `Redirect<T>::PATH` returns `T::PATH` (canonical path, not the old path)
/// - The type itself signals to developers that this path was redirected
///
/// ```rust,ignore
/// // In generated code from build.rs when a path is renamed:
/// pub mod item {
///     pub mod weapon {
///         // Old path "Item.Weapon.Sword" now redirects to "Equipment.Blade"
///         pub type Sword = bevy_tag::Redirect<crate::equipment::Blade>;
///     }
/// }
///
/// // Usage shows the redirect relationship in the type:
/// let tag: item::weapon::Sword = Redirect::new();
/// assert_eq!(tag.gid(), equipment::Blade::GID);  // Same GID
/// ```
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Redirect<T: NamespaceTag>(PhantomData<T>);

impl<T: NamespaceTag> Redirect<T> {
    /// Create a new redirect instance.
    #[inline]
    pub const fn new() -> Self {
        Self(PhantomData)
    }

    /// Get the canonical tag type this redirects to.
    pub const fn canonical_path() -> &'static str {
        T::PATH
    }
}

impl<T: NamespaceTag> Default for Redirect<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}

impl<T: NamespaceTag> core::fmt::Debug for Redirect<T> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "Redirect<{}>", T::PATH)
    }
}

impl<T: NamespaceTag> NamespaceTag for Redirect<T> {
    /// Returns the CANONICAL path (T::PATH), not the old redirected path.
    /// This ensures `path_of()` always returns the canonical location.
    const PATH: &'static str = T::PATH;

    /// Depth matches the canonical tag.
    const DEPTH: u8 = T::DEPTH;

    /// GID matches the canonical tag — the core redirect invariant.
    const GID: GID = T::GID;
}

impl<T: NamespaceTag + HasData> HasData for Redirect<T> {
    type Data = T::Data;
}

/// A compile-time namespace tag, generated by the `namespace!` macro.
///
/// Each node in the namespace tree gets a zero-sized Tag type with
/// associated constants for path, depth, and stable GID.
///
/// ```rust,ignore
/// namespace! {
///     pub mod ids {
///         Movement { Idle; Running; }
///     }
/// }
///
/// // Generated:
/// // ids::Movement::Idle implements NamespaceTag
/// // ids::Movement::Idle::PATH  = "Movement.Idle"
/// // ids::Movement::Idle::DEPTH = 1
/// // ids::Movement::Idle::GID   = 0x... (const hierarchical hash)
/// ```
pub trait NamespaceTag: Copy + 'static {
    /// Full dot-separated path, e.g. `"Movement.Idle"`.
    const PATH: &'static str;

    /// Depth in the tree (0 = top-level).
    const DEPTH: u8;

    /// Stable hierarchical GID, computed at compile time.
    ///
    /// This is a `const` value — no registry lookup needed.
    const GID: GID;

    /// Get the GID as a value (convenience method).
    #[inline]
    fn gid() -> GID {
        Self::GID
    }
}

/// Convert to GID. Implemented for raw `GID` (passthrough) and all `NamespaceTag` types.
pub trait IntoGid: Copy {
    fn into_gid(self) -> GID;
}

impl IntoGid for GID {
    #[inline]
    fn into_gid(self) -> GID {
        self
    }
}

impl<T: NamespaceTag> IntoGid for T {
    #[inline]
    fn into_gid(self) -> GID {
        T::GID
    }
}

/// Convert to GID using a specific registry instance.
///
/// Useful for ECS integrations where the registry is a `Res<NamespaceRegistry>`.
pub trait IntoGidWithRegistry: Copy {
    fn into_gid_with(self, registry: &NamespaceRegistry) -> GID;
}

impl IntoGidWithRegistry for GID {
    #[inline]
    fn into_gid_with(self, _registry: &NamespaceRegistry) -> GID {
        self
    }
}

impl<T: NamespaceTag> IntoGidWithRegistry for T {
    #[inline]
    fn into_gid_with(self, _registry: &NamespaceRegistry) -> GID {
        // Tag already knows its GID at compile time
        T::GID
    }
}

/// Convert a collection of items into a `Vec<GID>`.
pub trait IntoGids {
    fn into_gids(self) -> Vec<GID>;
}

impl<T: IntoGid> IntoGids for Vec<T> {
    #[inline]
    fn into_gids(self) -> Vec<GID> {
        self.into_iter().map(IntoGid::into_gid).collect()
    }
}

// Tuple impls for ergonomic multi-id passing (up to 12 elements)
macro_rules! impl_into_gids_tuple {
    ($($idx:tt $T:ident),+) => {
        impl<$($T: IntoGid),+> IntoGids for ($($T,)+) {
            #[inline]
            fn into_gids(self) -> Vec<GID> {
                vec![$(self.$idx.into_gid()),+]
            }
        }
    };
}

impl_into_gids_tuple!(0 A, 1 B);
impl_into_gids_tuple!(0 A, 1 B, 2 C);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G, 7 H);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G, 7 H, 8 I);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G, 7 H, 8 I, 9 J);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G, 7 H, 8 I, 9 J, 10 K);
impl_into_gids_tuple!(0 A, 1 B, 2 C, 3 D, 4 E, 5 F, 6 G, 7 H, 8 I, 9 J, 10 K, 11 L);

// Const array support
impl<T: IntoGid, const N: usize> IntoGids for [T; N] {
    #[inline]
    fn into_gids(self) -> Vec<GID> {
        self.into_iter().map(IntoGid::into_gid).collect()
    }
}

/// Marker trait for namespace tags that have associated serializable data.
///
/// This trait is automatically implemented by the `namespace!` macro when
/// a node is declared with a type parameter:
///
/// ```rust,ignore
/// namespace! {
///     pub mod ids {
///         Movement<MovementData>;  // generates HasData impl
///         Combat;                  // no HasData impl
///     }
/// }
/// ```
///
/// The associated `Data` type must implement `serde::Serialize + serde::Deserialize`.
pub trait HasData: NamespaceTag {
    /// The data type associated with this namespace tag.
    type Data: serde::Serialize + for<'de> serde::Deserialize<'de>;
}